domain People
{
  Person ::= new (name: String).
  Parent ::= new (parent: Person, child: Person).
  tooManyParents :- c is Person, count({ p | p is Parent(_, c) }) > 2.
  conforms no tooManyParents.
}

/* should be true */
/* qr Family People.conforms */
model Family of People
{
  p1 is Person("Elvis"),
  p2 is Person("Joe"),
  p3 is Person("Sally"),
  p4 is Person("Susan").

  Parent(p1, p4),
  Parent(p2, p4).
}

/* should be false */
/* qr BadFamily People.conforms */
model BadFamily of People
{
  p1 is Person("Elvis"),
  p2 is Person("Joe"),
  p3 is Person("Sally"),
  p4 is Person("Susan").

  Parent(p1, p4),
  Parent(p2, p4).
  Parent(p3, p4).
}

domain AlgTrees
{
  Node ::= new (left: any Node + {NIL},
    right: any Node + {NIL}).
  Root ::= new (root: any Node).
  isLength3 ::= (Root).
  isLength3(r) :- r is Root,
    r.root.left.left != NIL;
    r is Root,
    r.root.left.right != NIL;
    r is Root,
    r.root.right.left != NIL;
    r is Root,
    r.root.right.right != NIL.
  conforms no isLength3(_).
}

/* should be true */
/* qr Fex' AlgTrees.conforms */
model Fex' of AlgTrees
{
  Root(
    Node(
      Node(NIL, NIL),
      Node(NIL, NIL)
    )
  ).
}

/* should be false */
/* qr BadFex AlgTrees.conforms */
model BadFex of AlgTrees
{
  Root(
    Node(
      Node(
        Node(NIL, NIL), NIL),
      Node(NIL, NIL)
    )
  ).
}

domain FSM
{
  State ::= new (id: Integer).
  DirectedTransition ::= new (from: State + InitialState, to: State + FinalState).
  InitialState ::= new (s: State).
  FinalState ::= new (s: State).
  hasInitialState :- count({ initState | initState is InitialState }) = 1.
  path ::= (State + InitialState, State + FinalState).
  path(a, b) :- DirectedTransition(a, b);
    DirectedTransition(a, x), path(x, b).
  hasFullPath :- a is InitialState, b is FinalState, path(a, b).
  conforms hasInitialState.
  conforms hasFullPath.
}

/* should be false */
/* qr NoInitialState FSM.conforms */
model NoInitialState of FSM
{
  s is State(1).
}

/* should be false */
/* qr MultipleInitialStates FSM.conforms */
model MultipleInitialStates of FSM
{
  initState1 is InitialState(State(1)),
  initState2 is InitialState(State(2)).
}

/* should be true */
/* qr GoodFSM FSM.conforms */
model GoodFSM of FSM
{
  s1 is State(1).

  initState is InitialState(s1).
}
